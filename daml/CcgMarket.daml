{-# LANGUAGE ApplicativeDo #-}

daml 1.2
module CcgMarket
where

data CardDescription = CardDescription with
    publisher: Party
    description: Text
  deriving (Show, Eq)

template ProposeMarket
    with
        registry: Party
        auditor: Party
    where
        signatory registry
        ensure registry /= auditor

        controller auditor can
            AcceptMarket: ContractId Msa do
                create $ Msa registry auditor [] [] [] []

template Msa
    with
        registry: Party
        auditor: Party
        players: [Party]
        publishers: [Party]
        invitedPlayers: [Party]
        invitedPublishers: [Party]
    where
        signatory registry, auditor
        observer players <> publishers <> invitedPlayers <> invitedPublishers

        nonconsuming choice IssueCard: ContractId CardOffer
            with
                owner: Party
                description: CardDescription
            controller description.publisher
            do
                assert $ description.publisher `elem` publishers
                create CardOffer with registry; auditor; owner; description

        controller registry can
            nonconsuming SettleSwapObligation: (ContractId Card, ContractId Card)
                with
                    obligation: ContractId SwapObligation
                    card1Id: ContractId Card
                    card2Id: ContractId Card
                do
                    exercise obligation SettleObligation with card1Id; card2Id

            InvitePublisher: ContractId Msa
                with
                    invitee: Party
                do
                    assert $ invitee `notElem` publishers
                    assert $ invitee `notElem` invitedPublishers
                    create this with invitedPublishers = invitee :: invitedPublishers

            InvitePlayer: ContractId Msa
                with
                    invitee: Party
                do
                    assert $ invitee `notElem` publishers
                    assert $ invitee `notElem` invitedPlayers
                    create this with invitedPlayers = invitee :: invitedPlayers

        choice AcceptPublisher: ContractId Msa
            with
                accepter: Party
            controller accepter
            do
                assert $ accepter `elem` invitedPublishers
                create this with
                    publishers = accepter :: publishers
                    invitedPublishers = filter ((/=) accepter) invitedPublishers
        
        choice AcceptPlayer: ContractId Msa
            with
                accepter: Party
            controller accepter
            do
                assert $ accepter `elem` invitedPlayers
                create this with
                    players = accepter :: players
                    invitedPlayers = filter ((/=) accepter) invitedPlayers
        
        controller registry, auditor can
            UpdateCard: ContractId Card
                with
                    cardId: ContractId Card
                    owner: Party
                    description: CardDescription
                do
                    card <- fetch cardId
                    assert $ card.registry == registry
                    assert $ card.auditor == auditor

                    exercise cardId Archive
                    create card with owner; description

template CardOffer
    with
        registry: Party
        auditor: Party
        owner: Party
        description: CardDescription
    where
        signatory registry, auditor, description.publisher
        observer owner

        controller owner can
            AcceptCard: ContractId Card do
                create Card with registry; auditor; owner; description

template Card
    with
        registry: Party
        auditor: Party
        owner: Party
        description: CardDescription
    where
        signatory registry, auditor, description.publisher, owner

        choice TransferCard: ContractId Card
            with
                recipent: Party
            controller [ registry, auditor, owner, recipent ]
            do
                create Card with
                    registry
                    auditor
                    owner = recipent
                    description

template SwapOfferToTreat
    with
        player: Party
        informees: [Party]
        card: Card
    where
        signatory player
        observer informees
        ensure card.owner == player

        nonconsuming choice AcceptOfferToTreat: ContractId SwapOfferToContract
            with
                counter: Party
                counterCard: Card
            controller counter
                do
                    assert $ card.registry == counterCard.registry
                    assert $ card.auditor  == counterCard.auditor
                    assert $ card.owner    == player
                    assert $ counterCard.owner    == counter

                    create SwapOfferToContract with player; offerId = self; counter; counterCard
        
template SwapOfferToContract
    with
        player: Party
        offerId: ContractId SwapOfferToTreat
        counter: Party
        counterCard: Card
    where
        signatory counter
        ensure counterCard.owner == counter

        controller player can
            AcceptProposal: ContractId SwapObligation
                do
                    offer <- fetch offerId
                    assert $ offer.card.registry == counterCard.registry
                    assert $ offer.card.auditor == counterCard.auditor
                    assert $ offer.card.owner == player
                    assert $ counterCard.owner == counter

                    exercise offerId Archive
                    create SwapObligation with
                        registry = counterCard.registry
                        auditor = counterCard.auditor
                        party1 = player
                        card1 = offer.card
                        party2 = counter
                        card2 = counterCard

template SwapObligation
    with
        registry: Party
        auditor: Party
        party1: Party
        card1: Card
        party2: Party
        card2: Card
    where
        signatory party1, party2

        controller registry, auditor can
            SettleObligation: (ContractId Card, ContractId Card)
                with
                    card1Id: ContractId Card
                    card2Id: ContractId Card
                do
                    ledgerCard1 <- fetch card1Id
                    assert $ card1 == ledgerCard1
                    ledgerCard2 <- fetch card2Id
                    assert $ card2 == ledgerCard2
                    
                    (,) <$> exercise card2Id TransferCard with recipent = party1
                        <*> exercise card1Id TransferCard with recipent = party2

swapTrade : Scenario ()
swapTrade = do
    -----------------
    -- Market Setup
    -----------------

    -- Set up the participants in the marketplace
    -- Market operator and regulator/auditor
    registry <- getParty "Show me the money"
    auditor <- getParty "You cant have it"
    -- Publishers
    inlandSorc <- getParty "Inland Sorcerers"
    nineDisc <- getParty "Nine Disc Publishers"
    -- Gamers
    alice <- getParty "Alice"
    bob <- getParty "Bob"

    -- Setup the market and have the participants join
    mkp <- registry `submit` create ProposeMarket with registry; auditor
    msa <- auditor `submit` exercise mkp AcceptMarket
    msa <- registry `submit` exercise msa InvitePublisher with invitee = inlandSorc
    msa <- registry `submit` exercise msa InvitePublisher with invitee = nineDisc
    msa <- registry `submit` exercise msa InvitePlayer with invitee = alice
    msa <- registry `submit` exercise msa InvitePlayer with invitee = bob
    msa <- inlandSorc `submit` exercise msa AcceptPublisher with accepter = inlandSorc
    msa <- nineDisc `submit` exercise msa AcceptPublisher with accepter = nineDisc
    -- Note: Bob cannot accept on behalf of alice
    bob `submitMustFail` exercise msa AcceptPlayer with accepter = alice
    msa <- alice `submit` exercise msa AcceptPlayer with accepter = alice
    msa <- bob `submit` exercise msa AcceptPlayer with accepter = bob

    -- Issue two cards to Alice and Bob
    int <- inlandSorc `submit` exercise msa IssueCard with 
                owner = alice
                description = CardDescription with publisher = inlandSorc; description = "Immovable Force"
    forceId <- alice `submit` exercise int AcceptCard
    force <- alice `submit` fetch forceId

    int <- nineDisc `submit` exercise msa IssueCard with 
                owner = bob
                description = CardDescription with publisher = nineDisc; description = "Irresistable Object"
    objectId <- bob `submit` exercise int AcceptCard
    object <- bob `submit` fetch objectId

    ---------------------------------
    -- Privacy Demonstration Part 1
    ---------------------------------

    -- Alice doesn't know Bob's cards and vis versa
    alice `submitMustFail` fetch objectId
    bob `submitMustFail` fetch forceId
    -- Publishers know who owns their cards
    inlandSorc `submit` fetch forceId
    nineDisc `submit` fetch objectId
    -- But don't know who owns other cards
    inlandSorc `submitMustFail` fetch objectId
    nineDisc `submitMustFail` fetch forceId
    -- But the registry and auditor can see all ownership
    registry `submit` fetch forceId
    registry `submit` fetch objectId
    auditor `submit` fetch forceId
    auditor `submit` fetch objectId

    -----------------------------------
    -- Sale via Delgation to Registry
    -----------------------------------

    -- Alice doesn't want her card and offers to swap
    aliceOffer <- alice `submit` create SwapOfferToTreat with player = alice; card = force; informees = [ bob ]
    -- Bob can see the offer, but Publishers can't
    bob `submit` fetch aliceOffer
    inlandSorc `submitMustFail` fetch aliceOffer
    nineDisc `submitMustFail` fetch aliceOffer
    
    -- Bob decides to offer to swap his card with Alice
    bobProposal <- bob `submit` exercise aliceOffer AcceptOfferToTreat with counter = bob; counterCard = object

    -- Alice's offer is still valid ...
    alice `submit` fetch aliceOffer

    -- ... until Alice accepts Bob's proposal
    obligation <- alice `submit` exercise bobProposal AcceptProposal

    -- Then the offer is archived
    alice `submitMustFail` fetch aliceOffer
    -- As is Bob's proposal
    alice `submitMustFail` fetch bobProposal

    -- Instead there is now a SwapObligation
    -- This is needed because, even at this point, Bob and Alice can't see each other's cards on the ledger
    alice `submitMustFail` fetch objectId
    bob `submitMustFail` fetch forceId
    
    -- So the registry completes the trade
    -- But is prevented from bypassing the auditor
    registry `submitMustFail` exercise obligation SettleObligation with card1Id = forceId; card2Id = objectId
    -- So must use the MSA to get the delgated authorization of the auditor (which also gives the auditor visibility on the trade)
    (aliceCard, bobCard) <- registry `submit` exercise msa SettleSwapObligation with obligation; card1Id = forceId; card2Id = objectId

    ----------------------------
    -- Final Visibility Checks
    ----------------------------

    -- Alice and Bob has swapped their respective cards
    alice `submit` fetch aliceCard
    bob `submit` fetch bobCard
    -- But can't see each other's
    alice `submitMustFail` fetch bobCard
    bob `submitMustFail` fetch aliceCard

    -- Finally, the old cards have been archived ...
    inlandSorc `submitMustFail` fetch forceId
    nineDisc `submitMustFail` fetch objectId
    -- ... and have been informed of the new card owners
    inlandSorc `submit` fetch bobCard
    nineDisc `submit` fetch aliceCard

    pure ()
